<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Socket.IO Web Diagnostics</title>
    <style>
        body {
            font-family: 'Monaco', 'Courier New', monospace;
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            margin: 0;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: #4ec9b0;
            border-bottom: 2px solid #4ec9b0;
            padding-bottom: 10px;
        }

        h2 {
            color: #569cd6;
            margin-top: 30px;
        }

        .status-box {
            background: #2d2d30;
            border-left: 4px solid #007acc;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
        }

        .status-box.success {
            border-left-color: #4ec9b0;
        }

        .status-box.error {
            border-left-color: #f48771;
        }

        .status-box.warning {
            border-left-color: #dcdcaa;
        }

        .log-output {
            background: #1e1e1e;
            border: 1px solid #3e3e42;
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
            max-height: 400px;
            overflow-y: auto;
            font-size: 12px;
        }

        .log-entry {
            padding: 5px 0;
            border-bottom: 1px solid #2d2d30;
        }

        .log-entry.emit {
            color: #ce9178;
        }

        .log-entry.receive {
            color: #4ec9b0;
        }

        .log-entry.error {
            color: #f48771;
        }

        button {
            background: #007acc;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
        }

        button:hover {
            background: #005a9e;
        }

        button:disabled {
            background: #3e3e42;
            cursor: not-allowed;
        }

        input, select {
            background: #2d2d30;
            border: 1px solid #3e3e42;
            color: #d4d4d4;
            padding: 8px;
            margin: 5px;
            border-radius: 4px;
            font-family: inherit;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .info-card {
            background: #2d2d30;
            padding: 15px;
            border-radius: 4px;
            border-left: 3px solid #569cd6;
        }

        .info-label {
            color: #9cdcfe;
            font-size: 12px;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .info-value {
            color: #dcdcaa;
            font-size: 16px;
            word-break: break-all;
        }

        .test-section {
            background: #252526;
            padding: 20px;
            margin: 20px 0;
            border-radius: 4px;
        }

        code {
            background: #1e1e1e;
            padding: 2px 6px;
            border-radius: 3px;
            color: #ce9178;
        }

        .indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .indicator.online {
            background: #4ec9b0;
            box-shadow: 0 0 8px #4ec9b0;
        }

        .indicator.offline {
            background: #f48771;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç Socket.IO Web Messenger Diagnostics</h1>

        <!-- Connection Status -->
        <div class="info-grid">
            <div class="info-card">
                <div class="info-label">Connection Status</div>
                <div class="info-value">
                    <span class="indicator offline" id="status-indicator"></span>
                    <span id="connection-status">Disconnected</span>
                </div>
            </div>
            <div class="info-card">
                <div class="info-label">Socket ID</div>
                <div class="info-value" id="socket-id">-</div>
            </div>
            <div class="info-card">
                <div class="info-label">User ID</div>
                <div class="info-value" id="user-id">-</div>
            </div>
            <div class="info-card">
                <div class="info-label">Transport</div>
                <div class="info-value" id="transport">-</div>
            </div>
        </div>

        <!-- Configuration -->
        <h2>‚öôÔ∏è Configuration</h2>
        <div class="status-box">
            <label>Socket Server URL:</label><br>
            <input type="text" id="socket-url" value="https://worldmates.club:449" style="width: 400px;">
            <br><br>
            <label>Access Token (Session):</label><br>
            <input type="text" id="access-token" placeholder="Enter your access_token" style="width: 400px;">
            <br><br>
            <button onclick="connectSocket()">Connect</button>
            <button onclick="disconnectSocket()">Disconnect</button>
        </div>

        <!-- Connection Tests -->
        <h2>üß™ Connection Tests</h2>
        <div class="test-section">
            <button onclick="testJoinEvent()">Test Join Event</button>
            <button onclick="testTransport()">Check Transport</button>
            <button onclick="testRoomType()">Test Room Type</button>
            <button onclick="clearLogs()">Clear Logs</button>
        </div>

        <!-- Message Tests -->
        <h2>üí¨ Message Tests</h2>
        <div class="test-section">
            <label>Recipient ID:</label>
            <input type="number" id="test-recipient-id" value="24">
            <label>Message:</label>
            <input type="text" id="test-message" value="Test message from web" style="width: 300px;">
            <br><br>
            <button onclick="testSendMessage()">Send Test Message</button>
            <button onclick="testTyping()">Test Typing Indicator</button>
        </div>

        <!-- Event Monitoring -->
        <h2>üì° Event Log</h2>
        <div class="log-output" id="event-log">
            <div class="log-entry">Waiting for events...</div>
        </div>

        <!-- Detected Issues -->
        <h2>‚ö†Ô∏è Detected Issues</h2>
        <div id="issues-container">
            <div class="status-box">No diagnostic results yet. Click "Connect" to start.</div>
        </div>

        <!-- Recommendations -->
        <h2>üí° Recommendations</h2>
        <div id="recommendations-container">
            <div class="status-box">Connect to see recommendations.</div>
        </div>
    </div>

    <!-- Load Socket.IO -->
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>

    <script>
        let socket = null;
        let eventLog = [];
        let currentUserId = null;

        // Helper: Add log entry
        function addLog(type, message, data = null) {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = {
                timestamp,
                type,
                message,
                data
            };
            eventLog.push(logEntry);

            const logDiv = document.getElementById('event-log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;

            let logText = `[${timestamp}] ${message}`;
            if (data) {
                logText += `\n${JSON.stringify(data, null, 2)}`;
            }

            entry.textContent = logText;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function clearLogs() {
            eventLog = [];
            document.getElementById('event-log').innerHTML = '<div class="log-entry">Logs cleared.</div>';
        }

        // Connect to Socket.IO
        function connectSocket() {
            const url = document.getElementById('socket-url').value;
            const accessToken = document.getElementById('access-token').value;

            if (!accessToken) {
                alert('Please enter your access_token (session hash)');
                return;
            }

            addLog('emit', 'üîå Attempting connection...', { url, accessToken: accessToken.substring(0, 10) + '...' });

            socket = io(url, {
                transports: ['websocket', 'polling'],
                reconnection: true,
                reconnectionDelay: 1000,
                reconnectionDelayMax: 5000,
                reconnectionAttempts: 5,
                secure: true,
                rejectUnauthorized: false,
                query: {
                    access_token: accessToken
                }
            });

            // Connection events
            socket.on('connect', () => {
                addLog('receive', '‚úÖ Socket connected!', { socketId: socket.id });
                updateStatus('connected', socket.id, socket.io.engine.transport.name);

                // Auto-join
                socket.emit('join', {
                    user_id: accessToken
                }, (response) => {
                    addLog('receive', '‚úÖ Join response', response);
                    if (response && response.user_id) {
                        currentUserId = response.user_id;
                        document.getElementById('user-id').textContent = currentUserId;
                        checkIssues();
                    }
                });
            });

            socket.on('connect_error', (error) => {
                addLog('error', '‚ùå Connection error', { message: error.message });
                updateStatus('error', '-', '-');
                checkIssues();
            });

            socket.on('disconnect', (reason) => {
                addLog('error', '‚ùå Disconnected', { reason });
                updateStatus('disconnected', '-', '-');
            });

            socket.on('reconnect', (attemptNumber) => {
                addLog('receive', 'üîÑ Reconnected', { attemptNumber });
            });

            // Message events
            socket.on('private_message', (data) => {
                addLog('receive', 'üì® private_message', data);
            });

            socket.on('private_message_page', (data) => {
                addLog('receive', 'üì® private_message_page', data);
            });

            socket.on('new_message', (data) => {
                addLog('receive', 'üì® new_message', data);
            });

            // Status events
            socket.on('user_status_change', (data) => {
                addLog('receive', 'üë§ user_status_change', data);
            });

            socket.on('on_user_loggedin', (data) => {
                addLog('receive', '‚úÖ on_user_loggedin', data);
            });

            socket.on('on_user_loggedoff', (data) => {
                addLog('receive', '‚ùå on_user_loggedoff', data);
            });

            // Typing events
            socket.on('typing', (data) => {
                addLog('receive', '‚å®Ô∏è typing', data);
            });

            // Other events
            socket.on('lastseen', (data) => {
                addLog('receive', 'üëÅÔ∏è lastseen', data);
            });

            socket.on('messages_count', (data) => {
                addLog('receive', 'üìä messages_count', data);
            });

            // Monitor ALL events
            socket.onAny((event, ...args) => {
                if (!['connect', 'disconnect', 'private_message', 'private_message_page', 'new_message',
                       'user_status_change', 'typing', 'lastseen', 'messages_count',
                       'on_user_loggedin', 'on_user_loggedoff'].includes(event)) {
                    addLog('receive', `üì• ${event}`, args);
                }
            });
        }

        function disconnectSocket() {
            if (socket) {
                socket.disconnect();
                addLog('emit', 'üîå Manually disconnected');
                updateStatus('disconnected', '-', '-');
            }
        }

        function updateStatus(status, socketId, transport) {
            const indicator = document.getElementById('status-indicator');
            const statusText = document.getElementById('connection-status');
            const socketIdElem = document.getElementById('socket-id');
            const transportElem = document.getElementById('transport');

            socketIdElem.textContent = socketId;
            transportElem.textContent = transport;

            if (status === 'connected') {
                indicator.className = 'indicator online';
                statusText.textContent = 'Connected';
            } else {
                indicator.className = 'indicator offline';
                statusText.textContent = status === 'error' ? 'Error' : 'Disconnected';
            }
        }

        // Tests
        function testJoinEvent() {
            if (!socket || !socket.connected) {
                alert('Connect first!');
                return;
            }

            const accessToken = document.getElementById('access-token').value;

            addLog('emit', 'üî• Testing JOIN event...');
            socket.emit('join', {
                user_id: accessToken
            }, (response) => {
                addLog('receive', '‚úÖ JOIN callback', response);

                if (response && response.status === 200) {
                    addLog('receive', '‚úÖ JOIN SUCCESS - User ID: ' + response.user_id);
                } else {
                    addLog('error', '‚ùå JOIN FAILED', response);
                }
            });
        }

        function testTransport() {
            if (!socket || !socket.connected) {
                alert('Connect first!');
                return;
            }

            const transport = socket.io.engine.transport.name;
            addLog('emit', 'üîç Current transport: ' + transport);

            if (transport === 'websocket') {
                addLog('receive', '‚úÖ Using WebSocket (GOOD)');
            } else if (transport === 'polling') {
                addLog('error', '‚ö†Ô∏è Using polling (BAD - should be WebSocket)');
            }
        }

        function testRoomType() {
            if (!currentUserId) {
                alert('Not authenticated yet!');
                return;
            }

            addLog('emit', 'üîç Testing room types...');
            addLog('emit', `Current user ID: ${currentUserId} (type: ${typeof currentUserId})`);
            addLog('emit', `Server uses: String(${currentUserId}) = "${String(currentUserId)}"`);

            if (typeof currentUserId === 'number') {
                addLog('receive', '‚úÖ Numeric user_id detected (correct)');
            } else {
                addLog('error', '‚ö†Ô∏è Non-numeric user_id - check server response');
            }
        }

        function testSendMessage() {
            if (!socket || !socket.connected) {
                alert('Connect first!');
                return;
            }

            if (!currentUserId) {
                alert('Not authenticated yet!');
                return;
            }

            const recipientId = parseInt(document.getElementById('test-recipient-id').value);
            const message = document.getElementById('test-message').value;

            addLog('emit', 'üì§ Sending test message...', {
                from_id: currentUserId,
                to_id: recipientId,
                msg: message
            });

            socket.emit('private_message', {
                from_id: currentUserId,
                to_id: recipientId,
                msg: message,
                time: Math.floor(Date.now() / 1000)
            }, (response) => {
                addLog('receive', '‚úÖ Send message callback', response);

                if (response && response.status === 200) {
                    addLog('receive', '‚úÖ MESSAGE SENT successfully');
                } else {
                    addLog('error', '‚ùå MESSAGE SEND FAILED', response);
                }
            });
        }

        function testTyping() {
            if (!socket || !socket.connected) {
                alert('Connect first!');
                return;
            }

            const accessToken = document.getElementById('access-token').value;
            const recipientId = parseInt(document.getElementById('test-recipient-id').value);

            addLog('emit', '‚å®Ô∏è Sending typing indicator...');

            socket.emit('typing', {
                user_id: accessToken,
                recipient_id: recipientId,
                is_typing: 200  // 200 = typing, 300 = stopped
            });

            setTimeout(() => {
                addLog('emit', '‚å®Ô∏è Stopping typing...');
                socket.emit('typing_done', {
                    user_id: accessToken,
                    recipient_id: recipientId
                });
            }, 3000);
        }

        // Issue Detection
        function checkIssues() {
            const issues = [];
            const recommendations = [];

            // Check connection
            if (!socket || !socket.connected) {
                issues.push({
                    type: 'error',
                    title: 'Not Connected',
                    description: 'Socket.IO is not connected to the server.'
                });
                recommendations.push('Check server URL and ensure Node.js is running on port 449');
            }

            // Check transport
            if (socket && socket.connected) {
                const transport = socket.io.engine.transport.name;
                if (transport === 'polling') {
                    issues.push({
                        type: 'warning',
                        title: 'Using XHR Polling',
                        description: 'Connection is using polling instead of WebSocket (slower).'
                    });
                    recommendations.push('Ensure HAproxy is configured for WebSocket (mode tcp)');
                    recommendations.push('Check that transports: [\'websocket\', \'polling\'] is set');
                }
            }

            // Check authentication
            if (socket && socket.connected && !currentUserId) {
                issues.push({
                    type: 'error',
                    title: 'Authentication Failed',
                    description: 'Socket connected but JOIN event did not return user_id.'
                });
                recommendations.push('Verify access_token is correct');
                recommendations.push('Check JoinController.js is using correct session lookup');
            }

            // Check user_id type
            if (currentUserId && typeof currentUserId !== 'number') {
                issues.push({
                    type: 'warning',
                    title: 'User ID Type Mismatch',
                    description: `User ID is ${typeof currentUserId}, should be number.`
                });
                recommendations.push('Server should return numeric user_id in JOIN callback');
            }

            // Render issues
            const issuesContainer = document.getElementById('issues-container');
            if (issues.length === 0) {
                issuesContainer.innerHTML = '<div class="status-box success">‚úÖ No issues detected!</div>';
            } else {
                issuesContainer.innerHTML = issues.map(issue => `
                    <div class="status-box ${issue.type}">
                        <strong>${issue.title}</strong><br>
                        ${issue.description}
                    </div>
                `).join('');
            }

            // Render recommendations
            const recContainer = document.getElementById('recommendations-container');
            if (recommendations.length === 0) {
                recContainer.innerHTML = '<div class="status-box success">‚úÖ All good!</div>';
            } else {
                recContainer.innerHTML = recommendations.map(rec => `
                    <div class="status-box">üí° ${rec}</div>
                `).join('');
            }
        }

        // Auto-detect access token from cookies/localStorage
        window.addEventListener('load', () => {
            const cookieToken = document.cookie.split('; ').find(row => row.startsWith('access_token='));
            const localToken = localStorage.getItem('access_token');

            if (cookieToken) {
                document.getElementById('access-token').value = cookieToken.split('=')[1];
                addLog('receive', '‚úÖ Found access_token in cookies');
            } else if (localToken) {
                document.getElementById('access-token').value = localToken;
                addLog('receive', '‚úÖ Found access_token in localStorage');
            } else {
                addLog('error', '‚ö†Ô∏è No access_token found - please enter manually');
            }
        });
    </script>
</body>
</html>
